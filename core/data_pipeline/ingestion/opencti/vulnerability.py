from typing import Dict, Any, List, Optional
from core.utils.logger import setup_logger
from core.data_pipeline.ingestion.opencti.base import BaseIngestor
import re

logger = setup_logger(name="opencti_vuln", component_type="utils")

class VulnerabilityIngestor(BaseIngestor):
    def ingest_vulnerabilities(self, limit: int = 50, include_raw: bool = False) -> List[Dict[str, Any]]:
        """Retrieve vulnerabilities from OpenCTI"""
        cache_key = f"{self.__class__.__name__}:vulnerabilities:{limit}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
            
        logger.info("Fetching vulnerabilities from OpenCTI...")
        
        custom_filters = [{
            "key": "entity_type",
            "values": ["Vulnerability"]
        }]
        
        try:
            vulnerabilities = self.opencti.get_entities(filters=custom_filters, first=limit)
            
            if not vulnerabilities:
                logger.info("No vulnerabilities found.")
                return []
                
            logger.info(f"Retrieved {len(vulnerabilities)} vulnerabilities")
            structured_vulnerabilities = []
            
            for vuln in vulnerabilities:
                try:
                    if isinstance(vuln, dict):
                        structured = self._process_vulnerability(vuln, include_raw)
                        if structured:
                            structured_vulnerabilities.append(structured)
                    else:
                        logger.warning(f"Skipping non-dictionary vulnerability item: {type(vuln)}")
                except Exception as e:
                    vuln_id = vuln.get('id', 'unknown') if isinstance(vuln, dict) else 'unknown'
                    logger.error(f"Error processing vulnerability {vuln_id}: {str(e)}", exc_info=True)
                    
            logger.info(f"Structured {len(structured_vulnerabilities)} vulnerabilities")
            self._store_in_cache(cache_key, structured_vulnerabilities)
            return structured_vulnerabilities
        except Exception as e:
            logger.error(f"Error retrieving vulnerabilities: {str(e)}", exc_info=True)
            return []
        
    def _process_vulnerability(self, vuln: Dict[str, Any], include_raw: bool = False) -> Optional[Dict[str, Any]]:
        """Process a single vulnerability dictionary into a structured format."""
        
        if not isinstance(vuln, dict):
            logger.warning(f"_process_vulnerability received non-dict item: {type(vuln)}")
            return None

        cvss = 0.0
        if "x_opencti_base_score" in vuln:
            try:
                cvss = float(vuln.get("x_opencti_base_score", 0.0))
            except (ValueError, TypeError):
                cvss = 0.0
        elif "cvss" in vuln:
            try:
                cvss = float(vuln.get("cvss", 0.0))
            except (ValueError, TypeError):
                cvss = 0.0
        
        severity = "unknown"
        if cvss >= 9.0: severity = "critical"
        elif cvss >= 7.0: severity = "high"
        elif cvss >= 4.0: severity = "medium"
        elif cvss > 0: severity = "low"
            
        cve_id = ""
        name = vuln.get("name", "")
        if name and "CVE-" in name:
            cve_id = name
        elif "external_references" in vuln and isinstance(vuln["external_references"], list):
            for ref in vuln["external_references"]:
                if isinstance(ref, dict):
                    ext_id = ref.get("external_id", "")
                    if ref.get("source_name") == "cve" or (ext_id and "CVE-" in ext_id):
                        cve_id = ext_id
                        break
        
        processed_refs = []
        raw_refs_source = []
        
        if "objectRefs" in vuln and isinstance(vuln["objectRefs"], list):
             raw_refs_source = vuln["objectRefs"]
        else:
            try:
                raw_refs_source = self.opencti.relationship.list(entity_id=vuln.get("id"))
            except Exception as e:
                logger.error(f"Error getting related objects for vulnerability {vuln.get('id')}: {e}")
                raw_refs_source = []

        if not isinstance(raw_refs_source, list):
             logger.warning(f"Expected list for raw_refs_source, got {type(raw_refs_source)} for vuln {vuln.get('id')}")
             raw_refs_source = []

        for ref in raw_refs_source:
            if isinstance(ref, dict):
                ref_id = ref.get("id")
                ref_type = ref.get("entity_type") 
                ref_name = ref.get("name")

                if 'to' in ref and isinstance(ref.get('to'), dict):
                    target = ref.get('to')
                    ref_id = target.get("id", ref_id)
                    ref_type = target.get("entity_type", ref_type)
                    ref_name = target.get("name", ref_name)
                
                if ref_id and ref_type:
                     processed_refs.append({
                        "id": ref_id,
                        "type": ref_type,
                        "name": ref_name or "Unknown"
                    })      
                else:
                     logger.debug(f"Skipping ref in vuln {vuln.get('id')} due to missing id/type: {ref}")
            
            elif isinstance(ref, str):
                 logger.debug(f"Skipping string ref in vuln {vuln.get('id')}: {ref}")
                 pass
            
            else:
                logger.warning(f"Unexpected item type in objectRefs/relationships for vuln {vuln.get('id')}: {type(ref)}")

        # --- Process labels safely ---
        processed_labels = []
        object_label_data = vuln.get("objectLabel")
        if isinstance(object_label_data, dict):
            edges = object_label_data.get("edges", [])
            if isinstance(edges, list):
                 for edge in edges:
                    if isinstance(edge, dict):
                        node = edge.get("node")
                        if isinstance(node, dict):
                            label_value = node.get("value")
                            if label_value:
                                processed_labels.append(label_value)
            # Removed warning for non-list edges, default to []
        # Silently handle the case where objectLabel is a list or None
        # Only log if it's some other unexpected type (though unlikely)
        elif object_label_data is not None and not isinstance(object_label_data, list):
             logger.warning(f"Unexpected type for objectLabel, expected dict or list, got {type(object_label_data)} for vuln {vuln.get('id')}")

        # Create structured response
        structured = {
            "type": "vulnerability",
            "id": vuln.get("id"),
            "name": name,
            "cve_id": cve_id,
            "description": vuln.get("description", ""),
            "created_at": vuln.get("created_at", vuln.get("created")),
            "modified_at": vuln.get("modified_at", vuln.get("modified", vuln.get("created_at", vuln.get("created")))),
            "cvss": cvss,
            "severity": severity,
            "published": vuln.get("published"),
            "labels": processed_labels, # Use the safely processed list
            "object_refs": processed_refs,
            "object_refs_count": len(processed_refs)
        }
        
        if include_raw:
            structured["raw_data"] = vuln
            
        return structured 