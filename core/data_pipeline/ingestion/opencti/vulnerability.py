from typing import Dict, Any, List
from core.utils.logger import setup_logger
from core.data_pipeline.ingestion.opencti.base import BaseIngestor

logger = setup_logger(name="opencti_vuln", component_type="utils")

class VulnerabilityIngestor(BaseIngestor):
    def ingest_vulnerabilities(self, limit: int = 50, include_raw: bool = False) -> List[Dict[str, Any]]:
        """Retrieve vulnerabilities from OpenCTI"""
        cache_key = f"{self.__class__.__name__}:vulnerabilities:{limit}"
        cached = self._get_from_cache(cache_key)
        if cached:
            return cached
            
        logger.info("Fetching vulnerabilities from OpenCTI...")
        
        # We need to use a special query since vulnerabilities aren't directly exposed
        # in the Python client in the same way as other entities
        custom_filters = [{
            "key": "entity_type",
            "values": ["Vulnerability"]
        }]
        
        try:
            vulnerabilities = self.opencti.get_entities(filters=custom_filters, first=limit)
            
            if not vulnerabilities:
                logger.info("No vulnerabilities found.")
                return []
                
            logger.info(f"Retrieved {len(vulnerabilities)} vulnerabilities")
            structured_vulnerabilities = []
            
            for vuln in vulnerabilities:
                try:
                    structured = self._process_vulnerability(vuln, include_raw)
                    if structured:
                        structured_vulnerabilities.append(structured)
                except Exception as e:
                    logger.error(f"Error processing vulnerability {vuln.get('id', 'unknown')}: {str(e)}")
                    
            logger.info(f"Structured {len(structured_vulnerabilities)} vulnerabilities")
            self._store_in_cache(cache_key, structured_vulnerabilities)
            return structured_vulnerabilities
        except Exception as e:
            logger.error(f"Error retrieving vulnerabilities: {str(e)}")
            return []
        
    def _process_vulnerability(self, vuln: Dict[str, Any], include_raw: bool = False) -> Dict[str, Any]:
        # Default CVSS value
        cvss = 0.0
        
        # Try to extract CVSS score from different possible locations
        if "x_opencti_base_score" in vuln:
            cvss = float(vuln.get("x_opencti_base_score", 0.0))
        elif "cvss" in vuln:
            cvss = float(vuln.get("cvss", 0.0))
        
        # Determine severity based on CVSS
        if cvss >= 9.0:
            severity = "critical"
        elif cvss >= 7.0:
            severity = "high"
        elif cvss >= 4.0:
            severity = "medium"
        elif cvss > 0:
            severity = "low"
        else:
            severity = "unknown"
            
        # Extract CVE ID from name or external references
        cve_id = ""
        if "CVE-" in vuln.get("name", ""):
            cve_id = vuln.get("name", "")
        elif "external_references" in vuln and vuln["external_references"]:
            for ref in vuln["external_references"]:
                if ref.get("source_name") == "cve" or "CVE-" in ref.get("external_id", ""):
                    cve_id = ref.get("external_id", "")
                    break
        
        # Extract object references if available
        object_refs = []
        if "objectRefs" in vuln:
            object_refs = vuln["objectRefs"]
        else:
            # Get relationships for this vulnerability
            try:
                related_objects = self.opencti.relationship.list(entity_id=vuln.get("id"))
                object_refs = related_objects
            except Exception as e:
                logger.error(f"Error getting related objects for vulnerability {vuln.get('id')}: {e}")
        
        # Create structured response
        structured = {
            "type": "vulnerability",
            "id": vuln.get("id"),
            "name": vuln.get("name", "Unnamed Vulnerability"),
            "cve_id": cve_id,
            "description": vuln.get("description", ""),
            "created_at": vuln.get("created_at"),
            "modified_at": vuln.get("modified_at", vuln.get("created_at")),
            "cvss": cvss,
            "severity": severity,
            "published": vuln.get("published", vuln.get("created_at")),
            "labels": vuln.get("objectLabel", {}).get("edges", []),
            "object_refs": object_refs,
            "object_refs_count": len(object_refs)
        }
        
        # Include raw data if requested
        if include_raw:
            structured["raw_data"] = vuln
            
        logger.debug(f"Processed vulnerability: {vuln.get('name')}")
        return structured 